# -*- coding: utf-8 -*-
"""v2.1.0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19pTy0RtznE4ADztL7dSnkxiVE13Bqqtu
"""

!pip install python-Levenshtein

import json
from difflib import SequenceMatcher
import Levenshtein
from braille_dictionary import BRAILLE_DICTIONARY

CORRECTION_FILE = "corrections.json"


try:
    with open(CORRECTION_FILE, "r") as f:
        correction_history = json.load(f)
except FileNotFoundError:
    correction_history = {}

def save_corrections():
    with open(CORRECTION_FILE, "w") as f:
        json.dump(correction_history, f)

def parse_input(input_string):
    chars = input_string.strip().split()
    return [set(char.upper()) for char in chars]

def set_sequence_to_string(seq):
    return " ".join("".join(sorted(s)) for s in seq)

def length_tolerant_match_score(input_seq, word_seq):
    input_str = set_sequence_to_string(input_seq)
    word_str = set_sequence_to_string(word_seq)


    dist = Levenshtein.distance(input_str, word_str)
    max_len = max(len(input_str), len(word_str))
    similarity = 1 - dist / max_len if max_len else 1
    percent_similarity = round(similarity * 100)


    overlap_score = 0
    matcher = SequenceMatcher(None, [tuple(sorted(s)) for s in input_seq], [tuple(sorted(s)) for s in word_seq])
    for op, i1, i2, j1, j2 in matcher.get_opcodes():
        if op == 'equal':
            overlap_score += sum(len(input_seq[i] & word_seq[j]) for i, j in zip(range(i1, i2), range(j1, j2)))

    final_score = overlap_score + similarity * 5
    return final_score, percent_similarity

def suggest_top_words(user_input, top_n=3):
    parsed_input = parse_input(user_input)
    input_key = set_sequence_to_string(parsed_input)

    scored_words = []
    remembered_word = None

    for word, pattern in BRAILLE_DICTIONARY.items():
        score, percent = length_tolerant_match_score(parsed_input, pattern)

        if input_key in correction_history and correction_history[input_key] == word:
            score += 5
            remembered_word = word

        scored_words.append((score, word, percent))

    scored_words.sort(reverse=True)
    top = [(word, percent) for score, word, percent in scored_words[:top_n] if score > 0]
    return top, remembered_word

def real_time_loop():
    while True:
        user_input = input("\nAdd Braille character (or ENTER to reset, 'exit' to quit): ").strip()
        if user_input.lower() == 'exit':
            break
        if user_input == "":
            continue

        suggestions, remembered_word = suggest_top_words(user_input)

        if suggestions:
            print("Suggestions:")
            for word, percent in suggestions:
                print(f"‚Üí {word} ({percent}% similarity)")
            if remembered_word and any(word == remembered_word for word, _ in suggestions):
                print(f"‚úÖ Remembered from previous correction: your word might be '{remembered_word}'.")
        else:
            print("No match found.")

        corrected = input("‚ùì Did you mean one of these? If not, type correct word (ENTER if correct): ").strip().lower()
        if corrected and corrected not in [w for w, _ in suggestions]:
            parsed_input = parse_input(user_input)
            input_key = set_sequence_to_string(parsed_input)
            correction_history[input_key] = corrected
            save_corrections()
            print("üß† Thanks! We'll remember that for next time.")

if __name__ == "__main__":
    real_time_loop()

